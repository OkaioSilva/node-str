Primeiro: crie um arquivo ".js"
    -> dentro do arquivo, coloque o "use strict" para evitar problemas

Segundo: instalação de 3 pacotes
    npm install http express debug
    Importante: ao final, sempre ponha o "--save", ficando assim:
    npm install http express debug --save


Terceiro: criando um servidor web
    1 - importar o http, o debug, e o express
    const http = require('http')
    const debug = require('debug')('nodestr:server') isso é um nome que dou para o debug
    const express = require('express')

    2 - crie a aplicação:
        const app = express()
        const port = 3000; 
        app.set('port', port)
    
    !Cuidado! Atente-se a porta, pois para aplicação local, vai funcionar, mas quando subir a aplicação, nada garante que essa porta não esteja em uso, mas vamos ver isso futuramente 

    3 - criando o servidor
        const server = http.createServer(app);
        const router = express.Router();

    4 - configurando a primeira rota:
        const route = router.get('/', (req, res, next)=>{
            res.status(200).send({
                title: "Node Store API",
                Version: "0.0.1"
            });
        });
        app.use('/', route);

    5 - pedir para o servirdor ficar ouvindo:
        server.listen(port);
        console.log("API rodando na porta " + port);

Quarto:  Criar uma função para fazer a API rodar em ua porta disponível
    1 - função retirada do gerador de código do Express:
            function normalizePort(val){
                const port = parseInt(val, 10)

                if(isNaN(port)){
                    return val;
                }

                if(port >= 0){
                    return port
                }

                return false;
            }

    2 -  aplicar a função na constante da porta 
        const port = normalizePort(process.env.PORT || "3000");

    
    3 - pegar uma função para gerenciar error do servidor
        1 -
                 function onError(error){
                if(error.syscall !== 'listen'){
                     throw error;
                }

                const bind = typeof port == 'string' ? 'Pipe ' + port : 'Port ' + port;

                switch (error.code){
                    case 'EACCES' :
                        console.error( bind + 'requires elevated privileges');
                        process.exit(1);
                        break;
                    case 'EADDRINUSE':
                        console.error(bind + 'is already in use');
                        process.exit(1);
                        break;
                    default:
                        throw error;
                }
            }

        2 - após isso, chamar uma função do servidor
        server.on('error', onError) 
        isso abaixo da função de listen


Quinto: Iniciando o Debug
    1 - crie a função onListening() ou de sua preferência
                function onListening(){
                    const addr = server.address();
                    const bind = typeof addr === 'string' ? 'pipe' + addr :   'pipe' + addr.port;
                    debug('listening on ' + bind)
                }
    
    2- chame essa função abaixo do server.on
        server.on('listening', onListening)

Sexto: separando servidor 
    1 - Dica: não é bom trabalhar com servidor, rotas, api tudo no mesmo arquivo. Sendo assim, melhor que trabalhe com eles de forma separada para uma melhor organização e uma fácil manutenção de código 
        1.1 - crie uma pasta chamada "bin"
        1.2 - crie um arquivo dentro dessa pasta chamado de "server.js" e esse será o nosso servidor 
    Sendo assim, todas as funções de servidor e gerenciamento de erros vão ficar nessa pasta

    2 - crie uma pasta src ou de sua preferencia e crie um arquivo chamado app.js
        2.1 - dentro do app.js, vão ficar todas as aplicações qeu envolvem a aplicação
        (olhar o passo a passo dentro do arquivo)

    3 - feito essa separação, pode excluir o server.js da raiz do projeto, já tendo separado as aplicações, de nada mais servirá
        ! ATENÇÃO ! É o server.js da raiz, não o que está dentro da pasta "bin"

Sétimo: configurando o npm start
    1 - no package.json, na parte de scripts, estará assim:
        "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1"
        }

        você só precisa mudar para que fique assim: 

        "scripts": {
            ""start": "node ./bin/server.js"
        }

        Pronto, agora quando der um npm start, sua aplicação irá rodar

Oitavo: Nodemon
    npm install nodemon --save-dev
    Por que o -dev ?
    porque ficará somente como uma dependencia de desenvolvimento, não subirá para produção 


Décimo: CRUD REST
    1 - criando novas rotas no app.js
     a primeira será ".post":
        São vários métodos usados, porém, os mais usado são:  get, post, put e delete
        * get - obter informações
        * post - enviar informações
        * put - atualizar
        * delete - deletar informações
        Outro ponto importante é que posso ter a mesma rota para dois métodos, uma para get e outra para post
        sendo: 
            1 - const route = router.get('/', (req, res, next)=>{
                     res.status(200).send({
                        title: "Node Store API",
                        version: "0.0.1"
                    })
                })
                app.use('/', route)

            2 - const create = router.post('/', (req, res, next)=>{
                     res.status(200).send(req.body)
                })
                organizado lá em baixo com as outras app.use
                app.use('/products', create);

        Observação:
        status:
        200 - ok
        201 - created
        400 - error
        401 - não autenticado
        403 - acesso negado
        500 - internal server error ( não jogamos esse, qualquer erro que der na aplicção, ele vai jogar esse status)


    2 - body parser ( agora com o express não precisa mais instalar o body-parser):
        1 - acima das rotas criadas:
                app.use(express.urlencoded({extended:true}))
                app.use(express.json())


    3 - rota put:
        1 - vou realizar um put em um determinado id

        como faço para recuperar um determinado parametro ?
            const put = router.put('/:id', (req, res, next)=>{
                const id = req.params.id
                res.status(201).send({id: id, item: req.body})
             })

    4 - delete
        const del = router.delete('/', (req, res, next)=>{
        res.status(200).send(req.body)
    })


Déc. Primeiro: Separando as rotas   
        - Para ser mais organizado, vamos separar as rotas, tirando-as do "app.js"
            1- crie uma pasta chamada "routes", ou "rotas" dentro da pasta "src"
            2 - dentro da pasta "router", crie um arquivo chamado "index.js" ou de sua preferência
            3 - a rota principal que está no " app.js", esta:
                        const route = router.get('/', (req, res, next)=>{
                            res.status(200).send({
                            title: "Node Store API",
                            version: "0.0.1"
                            })
                        })
                será movida para dentro do "index.js". Atentando-se de importar o express e o express.Router()
                ficando exatamente como está no arquivo index.js e ao final exportar a contante "router"

            4- Agora, no "app.js", abaixo da criação da aplicação " 2 - crie a aplicação", você vai importar a rota que criou no index:
                - pode chamar do que quiser!
                const indexRoutes = require("./routes/index")
            
            5 - Ao fazer isso, lmebre-se que lá em baixo, em "app.use", não tem mais o route, como era antes de separar a rota, então, agora tem o "indexRoutes", ou o nome que você deu à variável.
                app.use('/', indexRoutes)

            
            6 - Agora, vamos separar as outras rotas restantes. Crie um arquivo chamado "products.js" dentro da pasta routes
             e copie as rotas de post, put e delete que antes foram feitas no app.js, lembrando de exportar o router também


Déc. Segundo: Controllers
         1- dentro da pasta "src", crie uma pasta 'controllers' e um arquivo chamado 'product-controller.js'
         2 - cole a rota principal do created "status(201)' exportando direto:
                exports.post = (req, res, next) => {
                    res.status(201).send(req.body)
                }
        3- após isso, pode ir no 'products.js' e substituir a parte da arrow function pela referencia do controller:
                router.post('/', controller.post);

        4 - repita essa ação com o put e o delete


Déc. terceiro: MongoDB Setup
        1 - MongoDB.com, faça o download, ou use o mlab do MongoDB criando um banco de dados onListenin
        2 - criando um bda online, você deve conectar ao vs code
        3 - copie a URI que o site do mongo oferece pós criação do banco de dados e cole no studio 3t ou aqui no vs code para uma conexão
        4 - mongoose : que irá permitir a criação de collections através de um Schema. Sendo assim:
                npm i mongoose --save
            Diferente do SQLserver que a gente executa uma conexão a cada request na nossa aplicação, aqui a nossa aplicação fica conectada direta no banco
        5 - vamos instanciar o mongoose e conectar ao MongoDB
            5.1 - no app.js:
                const mongoose = require('mongoose')
            
            5.2 - conexão com o MongoDB
                abaixo da aplicação:
                mongoose.connect('mongodb+srv://silv4kaio:<password>@node-store.cga1z.mongodb.net/')
                para melhorar a segurança do seu banco de dados com senhas, veja:
                https://www.youtube.com/watch?v=A8Pk-lkwgaw&t=572s 
                

Déc. Quarto: Models 
    Seguindo o padrão MVC (models views controllers):
        1 - crie uma pasta chamada "models" em src e detro um arquivo chamado product.js
        2 - No arquivo, iremos definir um Schema... 
            obs: O NoSql por padrão não tem Schema, ele é um Schemaless, mas o mongoose permite que criemos um Schema para as nossas validações, exemplo: não poderei cadastrar um produto com titulo repetido, etc
            então, para começar um Schema, precisamos de:
                2.1:
                     const mongoose = require("mongoose")
                     const Schema = mongoose.Schema;
                2.2:
                     const schema = new Schema({
                        aqui vamos compor nosso schema:
                        Já vem com id por padrão: _id
                        title:{
                            type: String,
                            required: true,
                            trim: true
                        },
                         slug:{
                            type: String,
                            required: true,
                            trim: true,
                            index: true,
                            unique: true  tem que ser unico porque não podemos ter 2 produtos com o mesmo slug para buscar
                        },
                     })
                     

                2.3:
                module.exports = mongoose.model('Product/ nome que você queira dar', schema)


Déc. quinto: Criando um produto:
    1 - comece importando o 'Product' que exportou em Models/products.js, no controllers/ product-controller assim como o mongoose, ficando assim:
            const mongoose = require('mongoose')
            const Product = mongoose.model('Product')
    
    2 - agora vamos instanciar o meu product
        exports.post = (req, res, next) => {
            let product = new Product(req.body);
            product.save().then(()=>{
                res.status(201).send({
                    message: "Produto cadastrado com sucesso"
                })
            }).catch((e)=>{
                res.status(400).send({message: "Falha ao cadastra produto", data: e})
            })
        }

    3 - carregue o model no app.js
        const Product = require('./models/product')

    4 - fazendo o teste no postman, vamos receber os erros de validação que colocamos..
        4.1 - tendo em mente isso, podemos ir no models/product.js  e editar a mensagem que aparece de erro, por exemplo:

             slug:{
                            type: String,
                            required: [true, 'O slug é obrigatório']
                            trim: true,
                            index: true,
                            unique: true  tem que ser unico porque não podemos ter 2 produtos com o mesmo slug para buscar
                        },    
            Dessa forma, mostrará a mensagem que você colocou. Isso pode ser feito para os demais!
            


Déc. sexto: Listando produtos   
        1 - em controllers/ product-controller.js  
             exports.get = (req, res, next) =>{
                 Product.find({}).then((data)=>{
                    res.status(200).send(data)
                 }).catch((e)=>{
                     res.status(400).send(e)
                 })
             }

        2 - após isso, vamos em rotas e vamos cadastrar uma rota para o get
            2.1 - feito isso, só conferir se o nodemon estárodando e se não mostrou nenhum erro e conferir no postman também
        
        3 - detalhe interessante é que podemos omitir o que não é tão interessante nas infromações, exempo:
           3.1 - quando olhamos no postman, essas são as informações que obtemos:
                        [
                            {
                                "_id": "66b53082b8c4e9f5958f65c3",
                                "title": "PC Gamer",
                                "slug": "pc-gamer",
                                "description": "PC gamer i9 gtx 4090 34gb RAM",
                                "price": 8499,
                                "active": true,
                                "tags": [
                                    "informática",
                                    "Pc",
                                    "games"
                                ],
                                "__v": 0
                            }
                        ]
            3.2 - Fica mais interessante mostrar apenas o title, slug e price, então fazemos assim:
                - em controllers/product-controller.js na função 'find({})', podemos passar um segundo parametro dizendo o que queremos mostrar:
                        exports.get = (req, res, next) =>{
                                Product.find({active: true}, 'title price slug').then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }
                - Dessa maneira, só iremos trazer os produtos ativos no sistema, o titulo, o preço e o slug

            
    - listando um produto pelo slug:
        1 -  Temos um método semelhando ao composta acima, porém, para fazer uma busca pelo o slug
            exports.getBySlug = (req, res, next) =>{
                                Product.find({slug: req.params.slug,active: true}, 'title description price slug tags').then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }

        2 - Após fazer isso, lembre-se de atribuir à rota:
            então, ficando assim em routes/productcs:
                router.get('/:slug', controller.getBySlug);
    

    - listando um produto pelo id:
            exports.getById = (req, res, next) =>{
                                Product.findById(req.params.id).then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }
            
        - Não esquecendo de add a rota:
                router.get('/:id', controller.getById);
            Dessa forma, vamos ter um conflito de rotas, sendo elas com o id e o slug. Para evitar esse conflito, vamos fazer assim:
                router.get('/admin/:id', controller.getById);


    - listando um produto pela tag:
             exports.getByTag = (req, res, next) =>{
                                Product.find({tags: req.params.tag, active: true}, 'title description price slug tags').then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }
            - Dessa forma, digitando "tags: nome da tag", ele já vai filtrar dentro do nosso próprio array de tags, porque quando definimos o produto, definimos como um array de strings

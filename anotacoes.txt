Primeiro: crie um arquivo ".js"
    -> dentro do arquivo, coloque o "use strict" para evitar problemas

Segundo: instalação de 3 pacotes
    npm install http express debug
    Importante: ao final, sempre ponha o "--save", ficando assim:
    npm install http express debug --save


Terceiro: criando um servidor web
    1 - importar o http, o debug, e o express
    const http = require('http')
    const debug = require('debug')('nodestr:server') isso é um nome que dou para o debug
    const express = require('express')

    2 - crie a aplicação:
        const app = express()
        const port = 3000; 
        app.set('port', port)
    
    !Cuidado! Atente-se a porta, pois para aplicação local, vai funcionar, mas quando subir a aplicação, nada garante que essa porta não esteja em uso, mas vamos ver isso futuramente 

    3 - criando o servidor
        const server = http.createServer(app);
        const router = express.Router();

    4 - configurando a primeira rota:
        const route = router.get('/', (req, res, next)=>{
            res.status(200).send({
                title: "Node Store API",
                Version: "0.0.1"
            });
        });
        app.use('/', route);

    5 - pedir para o servirdor ficar ouvindo:
        server.listen(port);
        console.log("API rodando na porta " + port);

Quarto:  Criar uma função para fazer a API rodar em uma porta disponível
    1 - função retirada do gerador de código do Express:
            function normalizePort(val){
                const port = parseInt(val, 10)

                if(isNaN(port)){
                    return val;
                }

                if(port >= 0){
                    return port
                }

                return false;
            }

    2 -  aplicar a função na constante da porta 
        const port = normalizePort(process.env.PORT || "3000");

    
    3 - pegar uma função para gerenciar error do servidor
        1 -
                 function onError(error){
                if(error.syscall !== 'listen'){
                     throw error;
                }

                const bind = typeof port == 'string' ? 'Pipe ' + port : 'Port ' + port;

                switch (error.code){
                    case 'EACCES' :
                        console.error( bind + 'requires elevated privileges');
                        process.exit(1);
                        break;
                    case 'EADDRINUSE':
                        console.error(bind + 'is already in use');
                        process.exit(1);
                        break;
                    default:
                        throw error;
                }
            }

        2 - após isso, chamar uma função do servidor
        server.on('error', onError) 
        isso abaixo da função de listen


Quinto: Iniciando o Debug
    1 - crie a função onListening() ou de sua preferência
                function onListening(){
                    const addr = server.address();
                    const bind = typeof addr === 'string' ? 'pipe' + addr :   'pipe' + addr.port;
                    debug('listening on ' + bind)
                }
    
    2- chame essa função abaixo do server.on
        server.on('listening', onListening)

Sexto: separando servidor 
    1 - Dica: não é bom trabalhar com servidor, rotas, api tudo no mesmo arquivo. Sendo assim, melhor que trabalhe com eles de forma separada para uma melhor organização e uma fácil manutenção de código 
        1.1 - crie uma pasta chamada "bin"
        1.2 - crie um arquivo dentro dessa pasta chamado de "server.js" e esse será o nosso servidor 
    Sendo assim, todas as funções de servidor e gerenciamento de erros vão ficar nessa pasta

    2 - crie uma pasta src ou de sua preferencia e crie um arquivo chamado app.js
        2.1 - dentro do app.js, vão ficar todas as aplicações qeu envolvem a aplicação
        (olhar o passo a passo dentro do arquivo)

    3 - feito essa separação, pode excluir o server.js da raiz do projeto, já tendo separado as aplicações, de nada mais servirá
        ! ATENÇÃO ! É o server.js da raiz, não o que está dentro da pasta "bin"

Sétimo: configurando o npm start
    1 - no package.json, na parte de scripts, estará assim:
        "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1"
        }

        você só precisa mudar para que fique assim: 

        "scripts": {
            ""start": "node ./bin/server.js"
        }

        Pronto, agora quando der um npm start, sua aplicação irá rodar

Oitavo: Nodemon
    npm install nodemon --save-dev
    Por que o -dev ?
    porque ficará somente como uma dependencia de desenvolvimento, não subirá para produção 


Décimo: CRUD REST
    1 - criando novas rotas no app.js
     a primeira será ".post":
        São vários métodos usados, porém, os mais usado são:  get, post, put e delete
        * get - obter informações
        * post - enviar informações
        * put - atualizar
        * delete - deletar informações
        Outro ponto importante é que posso ter a mesma rota para dois métodos, uma para get e outra para post
        sendo: 
            1 - const route = router.get('/', (req, res, next)=>{
                     res.status(200).send({
                        title: "Node Store API",
                        version: "0.0.1"
                    })
                })
                app.use('/', route)

            2 - const create = router.post('/', (req, res, next)=>{
                     res.status(200).send(req.body)
                })
                organizado lá em baixo com as outras app.use
                app.use('/products', create);

        Observação:
        status:
        200 - ok
        201 - created
        400 - error
        401 - não autenticado
        403 - acesso negado
        500 - internal server error ( não jogamos esse, qualquer erro que der na aplicção, ele vai jogar esse status)


    2 - body parser ( agora com o express não precisa mais instalar o body-parser):
        1 - acima das rotas criadas:
                app.use(express.urlencoded({extended:true}))
                app.use(express.json())


    3 - rota put:
        1 - vou realizar um put em um determinado id

        como faço para recuperar um determinado parametro ?
            const put = router.put('/:id', (req, res, next)=>{
                const id = req.params.id
                res.status(201).send({id: id, item: req.body})
             })

    4 - delete
        const del = router.delete('/', (req, res, next)=>{
        res.status(200).send(req.body)
    })


Déc. Primeiro: Separando as rotas   
        - Para ser mais organizado, vamos separar as rotas, tirando-as do "app.js"
            1- crie uma pasta chamada "routes", ou "rotas" dentro da pasta "src"
            2 - dentro da pasta "router", crie um arquivo chamado "index.js" ou de sua preferência
            3 - a rota principal que está no " app.js", esta:
                        const route = router.get('/', (req, res, next)=>{
                            res.status(200).send({
                            title: "Node Store API",
                            version: "0.0.1"
                            })
                        })
                será movida para dentro do "index.js". Atentando-se de importar o express e o express.Router()
                ficando exatamente como está no arquivo index.js e ao final exportar a contante "router"

            4- Agora, no "app.js", abaixo da criação da aplicação " 2 - crie a aplicação", você vai importar a rota que criou no index:
                - pode chamar do que quiser!
                const indexRoutes = require("./routes/index")
            
            5 - Ao fazer isso, lmebre-se que lá em baixo, em "app.use", não tem mais o route, como era antes de separar a rota, então, agora tem o "indexRoutes", ou o nome que você deu à variável.
                app.use('/', indexRoutes)

            
            6 - Agora, vamos separar as outras rotas restantes. Crie um arquivo chamado "products.js" dentro da pasta routes
             e copie as rotas de post, put e delete que antes foram feitas no app.js, lembrando de exportar o router também


Déc. Segundo: Controllers
         1- dentro da pasta "src", crie uma pasta 'controllers' e um arquivo chamado 'product-controller.js'
         2 - cole a rota principal do created "status(201)' exportando direto:
                exports.post = (req, res, next) => {
                    res.status(201).send(req.body)
                }
        3- após isso, pode ir no 'products.js' e substituir a parte da arrow function pela referencia do controller:
                router.post('/', controller.post);

        4 - repita essa ação com o put e o delete


Déc. terceiro: MongoDB Setup
        1 - MongoDB.com, faça o download, ou use o mlab do MongoDB criando um banco de dados onListenin
        2 - criando um bda online, você deve conectar ao vs code
        3 - copie a URI que o site do mongo oferece pós criação do banco de dados e cole no studio 3t ou aqui no vs code para uma conexão
        4 - mongoose : que irá permitir a criação de collections através de um Schema. Sendo assim:
                npm i mongoose --save
            Diferente do SQLserver que a gente executa uma conexão a cada request na nossa aplicação, aqui a nossa aplicação fica conectada direta no banco
        5 - vamos instanciar o mongoose e conectar ao MongoDB
            5.1 - no app.js:
                const mongoose = require('mongoose')
            
            5.2 - conexão com o MongoDB
                abaixo da aplicação:
                mongoose.connect('mongodb+srv://silv4kaio:<password>@node-store.cga1z.mongodb.net/')
                para melhorar a segurança do seu banco de dados com senhas, veja:
                https://www.youtube.com/watch?v=A8Pk-lkwgaw&t=572s 
                

Déc. Quarto: Models 
    Seguindo o padrão MVC (models views controllers):
        1 - crie uma pasta chamada "models" em src e detro um arquivo chamado product.js
        2 - No arquivo, iremos definir um Schema... 
            obs: O NoSql por padrão não tem Schema, ele é um Schemaless, mas o mongoose permite que criemos um Schema para as nossas validações, exemplo: não poderei cadastrar um produto com titulo repetido, etc
            então, para começar um Schema, precisamos de:
                2.1:
                     const mongoose = require("mongoose")
                     const Schema = mongoose.Schema;
                2.2:
                     const schema = new Schema({
                        aqui vamos compor nosso schema:
                        Já vem com id por padrão: _id
                        title:{
                            type: String,
                            required: true,
                            trim: true
                        },
                         slug:{
                            type: String,
                            required: true,
                            trim: true,
                            index: true,
                            unique: true  tem que ser unico porque não podemos ter 2 produtos com o mesmo slug para buscar
                        },
                     })
                     

                2.3:
                module.exports = mongoose.model('Product/ nome que você queira dar', schema)

                   
        

-----> CRUD:

Déc. quinto: Criando um produto:
    1 - comece importando o 'Product' que exportou em Models/products.js, no controllers/ product-controller assim como o mongoose, ficando assim:
            const mongoose = require('mongoose')
            const Product = mongoose.model('Product')
    
    2 - agora vamos instanciar o meu product
        exports.post = (req, res, next) => {
            let product = new Product(req.body);
            product.save().then(()=>{
                res.status(201).send({
                    message: "Produto cadastrado com sucesso"
                })
            }).catch((e)=>{
                res.status(400).send({message: "Falha ao cadastra produto", data: e})
            })
        }

    3 - carregue o model no app.js
        const Product = require('./models/product')

    4 - fazendo o teste no postman, vamos receber os erros de validação que colocamos..
        4.1 - tendo em mente isso, podemos ir no models/product.js  e editar a mensagem que aparece de erro, por exemplo:

             slug:{
                            type: String,
                            required: [true, 'O slug é obrigatório']
                            trim: true,
                            index: true,
                            unique: true  tem que ser unico porque não podemos ter 2 produtos com o mesmo slug para buscar
                        },    
            Dessa forma, mostrará a mensagem que você colocou. Isso pode ser feito para os demais!
            


Déc. sexto: Listando produtos   
        1 - em controllers/ product-controller.js  
             exports.get = (req, res, next) =>{
                 Product.find({}).then((data)=>{
                    res.status(200).send(data)
                 }).catch((e)=>{
                     res.status(400).send(e)
                 })
             }

        2 - após isso, vamos em rotas e vamos cadastrar uma rota para o get
            2.1 - feito isso, só conferir se o nodemon estárodando e se não mostrou nenhum erro e conferir no postman também
        
        3 - detalhe interessante é que podemos omitir o que não é tão interessante nas infromações, exempo:
           3.1 - quando olhamos no postman, essas são as informações que obtemos:
                        [
                            {
                                "_id": "66b53082b8c4e9f5958f65c3",
                                "title": "PC Gamer",
                                "slug": "pc-gamer",
                                "description": "PC gamer i9 gtx 4090 34gb RAM",
                                "price": 8499,
                                "active": true,
                                "tags": [
                                    "informática",
                                    "Pc",
                                    "games"
                                ],
                                "__v": 0
                            }
                        ]
            3.2 - Fica mais interessante mostrar apenas o title, slug e price, então fazemos assim:
                - em controllers/product-controller.js na função 'find({})', podemos passar um segundo parametro dizendo o que queremos mostrar:
                        exports.get = (req, res, next) =>{
                                Product.find({active: true}, 'title price slug').then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }
                - Dessa maneira, só iremos trazer os produtos ativos no sistema, o titulo, o preço e o slug

            
    - listando um produto pelo slug:
        1 -  Temos um método semelhando ao composta acima, porém, para fazer uma busca pelo o slug
            exports.getBySlug = (req, res, next) =>{
                                Product.find({slug: req.params.slug,active: true}, 'title description price slug tags').then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }

        2 - Após fazer isso, lembre-se de atribuir à rota:
            então, ficando assim em routes/productcs:
                router.get('/:slug', controller.getBySlug);
    

    - listando um produto pelo id:
            exports.getById = (req, res, next) =>{
                                Product.findById(req.params.id).then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }
            
        - Não esquecendo de add a rota:
                router.get('/:id', controller.getById);
            Dessa forma, vamos ter um conflito de rotas, sendo elas com o id e o slug. Para evitar esse conflito, vamos fazer assim:
                router.get('/admin/:id', controller.getById);


    - listando um produto pela tag:
             exports.getByTag = (req, res, next) =>{
                                Product.find({tags: req.params.tag, active: true}, 'title description price slug tags').then((data)=>{
                                 res.status(200).send(data)
                            }).catch((e)=>{
                                res.status(400).send(e)
                            })
                        }
            - Dessa forma, digitando "tags: nome da tag", ele já vai filtrar dentro do nosso próprio array de tags, porque quando definimos o produto, definimos como um array de strings



Déc. sétimo: Atualizando um produto:
    - em controllers/product-controller.js, já temos um método put, assim:
        exports.put = (req, res, next) => {
            const id = req.params.id;
            res.status(201).send({
                 id: id, 
                item: req.body
            })
        }
    
    Em que, anteriormete, já estávamos antentos que poderia ser alterado esse código, sendo assim, alterando ele, fica assim:
        exports.put = (req, res, next) => {
           Product.findByIdAndUpdate(req.params.id, {
                $set: {
                    title: req.body.title,
                    description: req.body.description,
                    price: req.body.price
                }
           }).then(()=>{
                res.status(200).send({
                    message: "Produto atualizado com sucesso!"
                })
           }).catch((e)=>{
                res.status(400).send({
                    message: "Falha ao atualizar produto", 
                    data: e
                })
           })

        }
    
    - explicando o código acima: Há outras formas de atualizar um dado, mas a mais simples é essa. Dito isso, basta chamar a nossa váriavel Product com o método ".findByIdAndUpdate", tendo como parametro o nosso "req.params.id", sendo composto também por um objeto: 
                $set: {
                    title: req.body.title,
                    description: req.body.description,
                    price: req.body.price
                }
    Em que o "$set" vai setar o que veio da requisição para o que vai ser alterado no meu produto, no nosso caso, por hora, title, description e price.
    Após isso, a nossa verificação se está tudo ok, ou não.
     - Para conferir, vá ao postman e dê um put com "localhost:3000/products/id do produto", na parte do body, você digita o que você quer alterar, no nosso caso: title, description e price.
        Assim, por exemplo:
            {
                 "title": "Cadeira gamer",
                 "description": "Cadeira gamer",
                 "price": "1200"
            }


Déc. oitavo: Excluindo um produto
    antes:
        exports.delete = (req, res, next) => {
            res.status(200).send(req.body)
         }

    Agora:
        exports.delete = (req, res, next) => {
            Product.findOneAndDelete(req.params.id).then(()=>{
                 res.status(200).send({
                 message: "Produto removido com sucesso!"
                    })
                }).catch((e)=>{
                    res.status(400).send({
                    message: "Falha ao remover produto", 
                     data: e
                    })
                })
            }

    Lembrando que o "findOneAndDelete(req.params.id)", se você não se sentir confortável passando o id pelo url para apagar, você pode fazer da seguinte forma: findOneAndDelete(req.body.id)
    e digitar no corpo da aplicação, ou em um input, caso tenha programado um.
        No corpo(postman):
                {
                    "id": id do produto que desejar remover
                }
        Vale ressaltar que se optar por essa forma "findOneAndDelete(req.params.id)", você precisa mapear o id em routes/products.js
         na rota de delete -> router.delete('/', controller.delete), ficando assim -> router.delete('/:id', controller.delete)
        Caso prefira o outro jeito, não precisa mapear esse id, somente passá-lo no body mesmo.



Déc. Nono: Validações 
        1 - Vamos criar uma espécie de  validação sem que precisemos do mongoose para isso
            1.1 - dentro da pasta "src", crie uma pasta para essas validações. Chame do que quiser!
                Eu vou acompanhar o que está sendo passado em aula e chamar de "validators"
                Dentro desta pasta, crie um arquivo. Seguindo a aula, chamarei de "fluent-validator.js"
            
            1.2 - Dentro de "fluent-validator.js", faça as validações que o professor explica no vídeo. Aqui, ficará a explicação do conceito de cada uma.
                1ª - uma lista de erros " array "
                2ª - uma função que faz o papel de consultar essa lista de erros caso tenho um erro na memória
                    - Os métodos:
                    1º - isRequired - recebo um valor e uma mensagem (value, message) - campo não pode ser menor que 0 ou igual a 0
                    2ª - hasMinLen - tem um mínimo de caracter
                    3ª - hasMaxLen - tem um máximo de caracter
                    4º - isFixedLen - tem um tamanho fixo 
                    5º - isEmail - vai verificar se é email com isso:
                        let reg = new RegExp(/^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/)

                    6º - Retorno da lista de erros
                    7º - temos um clear
                    8º - depois um metodo "isValid" para validar se é válido ou não 
                    9ª - por fim, temos a exportação da função " ValidationContract "

        2 - Agora, vamos importar esse módulo no nosso 'product-contoller.js"
            2.1 - Agora, no método 'POST', vamos inicializar as validações
                let contract = new ValidationContract(); 
            2.2 - Agor vamos pegar o que veio no request e fazer a validação:
                 contract.hasMinLen(req.body.title, 3, 'O título deve conter pelo menos 3 caracteres')
                 contract.hasMinLen(req.body.slug, 3, 'O slug deve conter pelo menos 3 caracteres')
                 contract.hasMinLen(req.body.description, 3, 'A descrição deve conter pelo menos 3 caracteres')
            2.3 - agora, vamos verificar se os dados são inválidos:
                         if(!contract.isValid()){
                               res.status(400).send(contract.errors()).end();
                                return;
                          }
            Esse contract existe apenas para evitar os inúmeros ifs 



Repositório  pattern: 
    - Ele isola todo acesso dados da sua aplicação, dos seus controllers, no caso. 
Como ?
    - Cria uma function que vai ao banco ou uma fonte de dados e retorna pra gente tudo o que precisamos. Eu delego a responsabilidade de acesso a dados de um Repositório
    Ex: preciso da lista de produtos. Onde ele vai buscar isso, não sei. Isso é um problema dele e o repositório é responsável por obter a lista de produtos
    Isso facilita a gente em diversas frentes, umas delas é se você tem uma mudança constante na estrutura de dados da sua aplicação, ou no armazenamento de dados
    As vezes você está trabalhando em um aplicação pequena, uma aplicação que faz tudo e, a medida em que cresceu, você precisa segmentar em serviços, então, agora, não vou mais ler o produto do meu SQLserver ou do meu mongoDb, eu vou ler meu produto de um outro serviço, sendo assim, vou ter que fazer um http request, etc. 
    Então, se você trabalha com repositório pattern, não importa onde está a sua lista de produtos, onde estão armazenados, como você faz para armazenar, nada disso importa. O que importa é que eu passo um produto, você salva ele no banco e que peço uma lista de produtos e você me retorna 

Dito isso, vamos lá...

Vigéssimo: repositorios 
        1 - criem uma pasta para o Repositório pattern
        2 - dentro dessa pasta, crie um arquivo .js, eu vou seguir a aula e chamar de "product-repository"
        3 - vamos importar o mongoose e o model de Product
        4 - faremos assim: 
            4.1 -  exports.get = ()=>{
                return Product.find({active: true}, 'title price slug')
            }
            4.2 -agora em controllers/product-controller :
            vamos importar o repositorios:
                4.2.1 - const repository = require('../repositories/product-repository) e, a parte que copiou do exports.get " Product.find({active: true}, 'title price slug')" você substitui poelo nome da variavél que criou, pois ela vai buscar a referencia lá no repositorio, meu exemplo fica:

                exports.get = (req, res, next) =>{
                    repository.get().then((data)=>{
                        res.status(200).send(data)
                     }).catch((e)=>{
                         res.status(400).send(e)
                    })
                }
 
        5 - Após fazer isso com o primeiro método .get, vamos fazer isso com os outros ( getBySlug, getById e getByTag)


Vig. Primeiro: Async/Await
       - Em controllers/product-controller, temos as promisses, então, se você apenas der um " repository.get();" receberemos um undefined, pois não temos as informações finais ainda, o repository.get retorna pra gente uma promeça. Ele faz assim: Eu vou executar aqui e quando estiver pronto, eu te chamo... Desse modo, temos, no fim o then e o catch para tratar isso 
       
       então, o que acontece... Muitas vezes, você vai querer você vai querer executar um método assincrono para depois prosseguir com sua requisição. Por exemplo: querer ver se o usuário já está cadastrado na base, se ele estiver, você dá um return, se não estiver você processegue com a requisição
       E ai, você tem que encadear promisses

       vamos lá: vamos tranformar o nossso método get em Async/Await
        em repositories/product-repository.js
            vamos mudar isso:   
            exports.get = ()=>{
                return Product.find({
                    active: true}, 
                    'title price slug')
            }
            Para:
            exports.get = async()=>{
                const res = await Product.find({
                    active: true}, 
                    'title price slug')
                    return res
            }

        - Mas se deixar assim, vamos ter um problema, pois ele vai chamar then lá, os métodos para formatar os dados, retornar o JSON aqui pra gente para podermos retornar para tela e daí, obviamente, teremos que tratar isso dentro de um try/catch porque ele não vai passar pelo método Errors que a gente tinha antes, então, vamos te que mudar o código lá no nosso controller (controllers/product-controller)
         - Se a gente colocou Async/Await no nosso repository, temos que colocar no nosso controller também:
                Antes:
                    exports.get = (req, res, next)=>{
                        repository.get().then((data)=>{
                            res.status(200).send(data)
                        }).catch((e)=>{
                            res.status(400).send(e)
                        })
                    }

                Depois:
                     exports.get = async(req, res, next)=>{
                        let data = await repository.get()
                            res.status(200).send(data)
                    }   

            - Agora, é interessante tratarmos os erros, já que não temos mais, então é legal tratarmos isso dentro de um try/catch:
                     exports.get = async(req, res, next)=>{
                        try{
                        let data = await repository.get()
                        res.status(200).send(data)
                        } catch(e){
                            res.status(500).send({
                                message: 'Falha ao processar sua requisição'
                            })
                        }
                    }  

            Feito isso com o primeiro, vamos fazer com os demais.


Vig. Segundo: Revisitando os models: Customer
    1 - em models crie um arquivo para os clientes, chamerei de "customer" como na aula
        Nesse arquivo, teremos um novo model, um novo Schema com nome, email e senha:
        "use strict";
                // 1 - carregando o mongoose e o Schema
                const mongoose = require("mongoose");
                const Schema = mongoose.Schema;

                // 2 - schema
                const schema = new Schema({
                    name:{
                        type: String,
                        required: true
                    }, 
                    email:{
                        type: String,
                        required: true
                    }, 
                    password:{
                        type: String,
                        required: true
                    }, 

                })

                module.exports = mongoose.model('Customer', schema)

            - criado isso, não podemos esquecer de carregar esse nosso model no app.js

    2 - order 
        Para economizar tempo, vamos copiar os arquivos do costumer, para ser mais simples e vamos mudar algumas coisas 
                            const schema = new Schema({
                            customer:{
                                type: mongoose.Schema.Types.ObjectId,
                                ref: 'Customer'
                            },
                            number:{
                                type: String,
                                required: true
                            },
                            createDate:{
                                type: Date,
                                required: true,
                                default: Date.now
                            },
                            status:{
                                type: String,
                                required: true,
                                enum: ['created', 'done'],
                                default: 'created'
                            }, 
                            items:[{
                                quantity:{
                                    type: Number,
                                    required: true,
                                    default: 1
                                },
                                price:{
                                    type: Number,
                                    required: true
                                },
                                product:{
                                    type: mongoose.Schema.Types.ObjectId,
                                    ref: 'Product'
                                }
                            }] 

                        })

    - Após isso, vamos importar no app também 



Vig. terceiro: Revisitando os controllers: Customer
        1 - Vá em controllers, crie um novo arquivo, chame do que quiser, mas chamarei de customer-controller.js como na aula, faça o mesmo em repositories e crie um customer-repository.js

        2- vá em product-repository, copie os módulos, copie os métodos .get e .create e cole em customer-repository.js..
            2.1 - Na aula 28, o professor, de início, deix ao método get para depois, focando somente no create, mas antes disso, ele importar o model "customer", ficando assim o arquivo:
                    'use strict'
                    const mongoose = require('mongoose')
                    const Customer = mongoose.model('Customer')

                    exports.create = async(data)=>{
                    let customer = new Customer(data);
                    await customer.save()
                    }

            2.2 - O professor não cria o edit e o delete, pois já criamos em product e é tudo a mesma coisa (Se preferir, posso criar depois)
        
        3 - Faremos a mesma coisa para o customer-controller, importando os módulos:
            "use strict";
            const ValidationContract = require("../validators/fluent-validator");
            const repository = require("../repositories/customer-repository");

            - não importamos o mongoose, pois já está sendo usado em repositories, e estamos importando de lá
            3.1 - Vamos pegar do product-controller o método post e colar em nosso customer-controller e alterar os campos de requisição para name, email e password, como criamos no model. 
                - lembre-se, na parte de email, temos uma validação no fluent-validation de email, vamos usar também, ficando assim:

                exports.post = async (req, res, next) => {
                let contract = new ValidationContract();
                contract.hasMinLen(req.body.name, 4, "O nome deve conter pelo menos 4 caracteres");
                contract.isEmail(req.body.email, "E-mail inválido");
                contract.hasMinLen(req.body.password, 6, "A senha deve conter pelo menos 6 caracteres");

                //11 - Se os dados forem inválidos:
                if (!contract.isValid()) {
                    res.status(400).send(contract.errors()).end();
                    return;
                }
                
                try {
                    await repository.create(req.body);
                    res.status(201).send({message: "Cliente cadastrado com sucesso",
                });
                } catch (e) {
                    res.status(500).send({message: "Falha ao cadastrar cliente" + e,});
                }
            };

        4 - feito isso, precisamos de uma nova rota, certo?
            Vamos em routes e vamos criar uma nova rota para customer, "customer-route.js"
            carregar os módulos:
                    'use strict'
                    // 1 - importação
                    const express = require('express')
                    const router = express.Router()
                    //3 - referenciar o controller
                    const controller = require('../controllers/customer-controller')

            E carregar a rota post e exportar:
                    router.post('/', controller.post);

                    module.exports = router;

        5 - feito isso, vamos no nosso app.js e carregar a nossa rota
               const customerRoutes = require('./routes/customer-route')

               5.1 - lembrando de carregar ela no app.use para podermos acessar a rota
                    app.use("/customers", customerRoutes)


vig. quarto:  Revisitando os Controllers: Order
        1 - Vamos começar pelo repository. Vamos criar um order-repository.js
        2 - dentro desse  arquivo vamos ter os módulos e os métodos get e create:
                'use strict'
                //1 - carregando módulos
                const mongoose = require('mongoose')
                const Order = mongoose.model('Order')


                exports.get = async()=>{
                    const res = await Order.find({})
                    return res
                }

                exports.create = async(data)=>{
                    let order = new Order(data);
                    await order.save()
                }

            - no get, por enquanto, não teremos nenhum filtro para as buscas
        
        3 - Agora, vamos criar um order-controller em controllers
            dentro desse arquivo, vamos ter os módulos e o método get

            "use strict";

            const ValidationContract = require("../validators/fluent-validator");
            const repository = require("../repositories/order-repository");

            //2 - exportando o post
            //post
            exports.post = async (req, res, next) => {
                // 3 - inicializando as validações do fluent-validator
                
                // depois fazer as validações de acordo com o model order!!!

                //4 - Se os dados forem inválidos:
                if (!contract.isValid()) {
                    res.status(400).send(contract.errors()).end();
                    return;
                }
                // 5 - try/catch
                try {
                    await repository.create(req.body);
                    res.status(201).send({message: "Pedido cadastrado com sucesso",
                });
                } catch (e) {
                    res.status(500).send({message: "Falha ao cadastrar pedido" + e,});
                }
            };


        !!!! -
            Na parte do "req.body" do código, precisamos do número do pedido, não iremos receber, por isso, temos que gerá-lo aqui
            Nesse caso, vamos fazer um guid para que possamos gerar um número para esse pedido. 
            -- Há um pacote no node que é realmente o guid:
                    npm install guid --save
            - Feito a instalação do guid, vamos importá-lo 
                const guid = require('guid');
            - Agora, vamos substituir o "req.body", por:
                    ({
                      customer: req.body.customer,
                      number: guid.raw().substring(0,6),
                      items: req.body.items
                    })
                        
                - em "number = guid.raw().substring(0,6)" : Isso vai gerar um guid pra mim e vou pegar somente os 6 primeiros caracteres

        4 - nas rotas, agora temos um novo arquivo chamado de order-route.js
            Vamos copiar os códigos do customer-route e colar no nosso order-route, alterando somente o controller.
            - Após isso, vamos adicionar o método get aqui e no nosso order-controller

        5 - testado no postman, deu tudo certo, porém, não está tão interessante porque não trouxe a informação do produto nem do cliente.
            5.1 - existe uma função chamada "populate()" que faz popular esses campos trazendo essas informações para gente.
            5.2 - vá em order-repository e adicione o popolate() no método get:
                    exports.get = async()=>{
                    const res = await Order.find({}, 'number status customer items').populate('customer', 'name').populate('items.product', 'title')
                    return res
                }

Vig. Quinto: Arquivo de configurações
    - Se notarmos, nós não salvamos a senha encripitada e nossa conexão com o mongoose está também avulso, não está passando por uma string de conexão nem um arquivo de configuração;
    Além disso, vamos precisar de configuração para envio d emails e várias outras situações.
     Vamos lá então:
        1- Em src, crie um arquivo para essas configurações
        2- no arquivo de config. teremos nossas configurações de conexão ao banco e uma hash de senha;
            module.exports = {
            connectionString: 'mongodb+srv://silv4kaio:<password>@node-store.cga1z.mongodb.net/',
            sendGridKey: '',
            containerConnectionString: ''
        }

        - Na aula, o professor usa uma Salt key global, não explicou como fez, nem como gerou, mas temos uma ideia usando o bcrypt com a função salt:
            https://medium.com/@amirakhaled2027/understanding-salt-in-node-js-a-comprehensive-guide-to-secure-password-hashing-54cc60890b4a

        3 - vamos importar nossa conexão ao banco no nosso app

Vig. Sexto: encripitando senhas:
    - Na aula 31, o professor usou uma KEY_SALT, como mencionei acima, não explicou como faz, porém, como no link que pesquisei, percebi que o bcrypt faz essa função de gerar um  senha de salt. Logo, substitui por esse método, fazendo um salt e unindo isso a um hash da senha. Inclui isso no custumer-controller.js:
        1 - importei o bcrypt
        2- instalei o pacote do md5 e importei também.
        3 - bcrypt e salt de senha:
            
                const salt = await bcrypt.genSalt(10);
                const hashPassword = await bcrypt.hash(req.body.password, salt);
               
            3.1 - ali vai puxar a senha que o usuário cadastrar e vai fazer o hash dessa senha e concatenar com o salt    

        4 - no método "POST", substitui lá no try, o método create(req.body), para:
            try {
                await repository.create({
                    name: req.body.name,
                    email: req.body.email,
                    password: md5(hashPassword)
                });
                res.status(201).send({message: "Cliente cadastrado com sucesso",
            });
            }

            - Feito isso, veja se não quebrou nada no nodemon e faça um post no postman para testar

            -- Consegui criar uma api key e usei o método dá aula. MAS o que foi escrito acima funciona muito bem também, cabe a pessoa decidir qual método usar. No md5(senha do usuário + a nossa salt key)

Vig. Sétimo: Enviando E-mail de Boas Vindas
    -há duas formas de você enviar um email:
        1- Através de um SMTP: gmail, hotmail, ou qualquer outro email que permita isso
        2- Através de um serviço, como um sendgrid, por exemplo

        Obs: Por que é ruim você fazer um envio por um SMTP pessoa? Se algumas pessoas começarem a marcar a sua mensagem como span, já era. A probabilidade de um gmail mandando 30 a 40 emails por minuto ser bloqueado é muito grande 

        Usei o mailerSend para enviar as mensagens no email.
        - Na aula, o professor usa o sendGrid, mas não consegui acessa-lo, então, busquei outros meios
        - Na aula, ele separa esse serviço em uma pasta e arquivo separado exportando, ainda não fiz, mas farei em breve essa separação de serviços
        Na prática, ficou assim:

        // mailersend modulos 
        const Recipient = require('mailersend').Recipient
        const EmailParams = require('mailersend').EmailParams
        const MailerSend = require('mailersend').MailerSend
        const Sender = require('mailersend').Sender

        Ai dentro do try no método "POST", coloquei as configurações de envio de email:
        
        //send email
        const mailerSendConfig = {apiKey: config.API_KEY}
        
        const mailerSend = new MailerSend(mailerSendConfig);
        
        const recipients = [new Recipient(req.body.email, req.body.name)];

        const sentFrom = new Sender('MS_JQRMc8@trial-yzkq3407wv0ld796.mlsender.net', 'Kaio')

        const emailParams = new EmailParams()
        .setFrom(sentFrom)
        .setTo(recipients)
        .setSubject('Bem vindo ao node Store')
        .setHtml(global.EMAIL_TMPL.replace('{0}', req.body.name))
        try{
            await mailerSend.email.send(emailParams)
        
        }catch(e){
            console.log(e)
        }

        - Lembrando que tenho que separar isso em uma pasta e arquivo e exportar

    ATUALIZAÇÕES:
        - Consegui separar o serviço de envio de email com o nodemailer!
        1 - instalei o pacote do nodemailer: npm install nodemailer
        2 - criei uma pasta de services e um arquivo "email-services.js"
        3 - fiz a configuração do nodemailer:

            const nodeMailer = require('nodemailer')

            const transporter = nodeMailer.createTransport({
                host: 'smtp.mailersend.net',
                port: 587,
                auth:{
                    user:'MS_JQRMc8@trial-yzkq3407wv0ld796.mlsender.net',
                    pass: 'D3pc8PSuEhrjZBBo'
                }
            })
            const sendEmail = (to, subject, body ) =>{
                transporter.sendMail({
                    from: '"Node Store"<MS_JQRMc8@trial-yzkq3407wv0ld796.mlsender.net>',
                    replyTo:'Souza_kaio@hotmail.com',
                    to,
                    subject,
                    html: body
                })
            }
            module.exports = sendEmail  

        4 - Na parte de host, port e auth, usei o serviço do mailerSend
        5 - exportei a função sendEmail.
        6 - em customer-controller.js, importei essa função e usei dentro do try do método POST




Vig. Oitavo: Upload de imagem do produto
    - No nosso produto, vamos ter uma imagem
   1 - vamos em models/product, e adicionar uma imagem
        -- após "tags", teremos "image"
        image:{
            type: string,
            required: true.
            trim: true
        }
       - Não é interessante armazenarmos imagens no banco, então, o que faremos ?
        -Vamos armazenar só o caminho dessa imagem, por isso o type é string, vamos pegar e transformar nossa imagem em base64
        Importante para pesquisar depois = ngImgCrop 
         No curso, o professor está ensinando como salvar essa imagem em um blob do azure, porque a api inteira irá para o azure  
    2 - vamos baixar o azure storage explorer, com esse cara, vamos conseguir explorar os nossos storages e vamos fazer um upload 
    3 - vamos no portal da azure
        3.1 - entrar na nossa conta e depois ir em storage
        3.2 - vamos criar um novo e faz como o professor ensinou na aula 33
    
    4 - vamos em chaves de acesse, copia sua connection string e cola no containerConnectionString

    5 - Envio de img:
        5.1 - no product-controller, no nosso método "POST", vamos receber a imagem(base64), vamos ter que salvar ela no azure para gerar a url dela e salvar essa url no banco
        5.2 - npm install azure-storage --save e importa ele no product-controller
        5.3 - no Try do nosso método "POST", vamos fazer a config
            - blob services
            const blobSvc = azure.createBlobService(config.containerConnectionString)

            let filename = guid.raw().toString() + '.jpg'; -> nome do arquivo randomico 
            let rawdata = req.body.image; 
            let matches = rawdata.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/); -> toda vez que convertemos uma img em basee64, ela vem com um cabeçalho dizendo que está em base64, usamos esse código para remover  os itens indesejaveis 
            let type = matches[1]; -> tipo da image
            let buffer = new Buffer.from(matches[2], 'base64'); -> novo buffer da img pra enviar

            // salva a imagem   
            await blobSvc.createBlockBlobFromText('product-images', filename, buffer, {
                contentType: type
            }), function(error, result, response){
                if(error){
                    filename = 'default-product.png'
                }
            }


    - Após isso, compor no "repository.create({
        title: req.body.title,
        slug: req.body.slug,
        description: req.body.description,
        price: req.body.price,
        active: true,
        tags: req.body.tags,
        images: 'Sua url de img no blob do azure' + filename 
    })"


Vig. Nono: Autenticação
   Vamos utilizar a autenticação via token, utilizando JWT, que é no formato JSON
    Começando instalando esse pacote:
    npm install jsonwebtoken --save

    Como vamos utilizar esse serviço em diversos locais, vamos criar uma pasta para ele:
        1 - no curso, o professor determina o nome como AUTH, dentro da pasta Services
        dentro do arquivo "auth-services.js": 
        // importar o jwt
        const jwt = require('jsonwebtoken')

        exports.generateToken = async(data) =>{
            // aqui vamos gerar os dados
            // Vamos passar os dados que vamos imputar dentro do token, no caso o email
            return jwt.sign(data, global.SALT_KEY, {expiresIn: '1d'})

            // e retornamos o json jwt, data, salt_key e os dias para expirar o token
        }
        
        exports.decodeToken = async(token)=>{
            // recebemos um token e tentamos verificar o token
            var data =  jwt.verify(token, global.SALT_KEY);
            return data; 
        }

        exports.authorize = function(req, res, next){
        // essa função vai servir como interceptador, então todas as rotas que quisermos banir, bloquear do usuário, vamos utilizar essa função

        let token = req.body.token || req.query.token || req.headers['x-access-token']
        // primeira coisa: vai ver no corpo, depois olha na query, depois no headers


        if(!token){
            res.status(401).json({
                message: 'Acesso restrito'
            })
        } else{
            jwt.verify(token, global.SALT_KEY, function(error, decoded){
                if(error){
                    res.status(401).json({
                        message: 'Token inválido'
                    })
                } else{
                    next();
                }
            })
        }
    }

      2 - Feito isso, o primeiro lugar que vamos usar esse cara é dentro das rotas
        2.1 - utilizando o authService na rota post
            router.post('/', authService.authorize ,controller.post);
        2.2 - agora, tentando no postman, receberei a mensagem de "acesso restrito" - se der isso, quer dizer que deu certo, até então

      3 - temos 3 meios de passar um token pra esse cara:
        1 - via queryString:  
                    localhost:3000/products?toekn=MEUTOKEN

        2 - ir no headers (postman)
            adicionar o "x-access-token" e por o meu token

        3 - ou ir no body e colocar o token:
        {
            "token": "MEUTOKEN"
        }


    -- Vamos seguir o professor e passar pelo headers;

    4 - Agora, precisamos fazer a autenticação do usuário
        4.1 - criar um método no customer-repository:
            exports.authenticate = async(data) =>{
                const res = await Customer.find({
                    email: data.email, password: data.password
                })
                return res
            }



Trig.: Recuperando dados do usuário logado

    -- Se olharmos no order-controller, toda vez que um pedido é feito temos o customer sendo passado no corpo da requisição, isso está muito errado, porque se passar o cliente o cliente que está fazendo o pedido, qualquer pessoa pode executar um pedido no nome de outra
       exports.post = async (req, res, next) => {
            try {
                //5 - mudar o req.body por um obj do model order e usando o guid para receber o nª do pedido
                await repository.create({
                    customer: req.body.customer, // mudar isso 
                    number: guid.raw().substring(0,6),
                    items: req.body.items
                });
                res.status(201).send({message: "Pedido cadastrado com sucesso",
            });
            } catch (e) {
                res.status(500).send({message: "Falha ao cadastrar pedido" + e,});
            }
        };
    -- como vamos fazer ? Precisamos pegar o token, desincriptar o token e vê o usuário logado;
        - Antes, vamos lá no customer-controller e na constante para gerar um token, vamos adicionar o id do usuário:
        const token = await authService.generateToken({
        id: customer._id,
        email: customer.email,
        name: customer.name
        })
    - O id vai facilitar a nossa vida na hora de decodificar o token. 
    -- Vamos lá, antes do repository.create, vamos obter as informações do token:
         exports.post = async (req, res, next) => {
            try {
                // recupera token   
                const token = req.body.token || req.query.token || req.headers['x-access-token];

                // decodifica token
                const data = await authService.decodeToken(token)

                //5 - mudar o req.body por um obj do model order e usando o guid para receber o nª do pedido
                await repository.create({
                    customer: req.body.customer, // mudar isso 
                    number: guid.raw().substring(0,6),
                    items: req.body.items
                });
                res.status(201).send({message: "Pedido cadastrado com sucesso",
            });
            } catch (e) {
                res.status(500).send({message: "Falha ao cadastrar pedido" + e,});
            }
        };

    - sabemos que vai ter um  token sempre, então não precisa verificar se tem data, pois já colocamos na rota o 'authorize'
    sendo assim, se não tiver um token válido, ele nem vai chegar aqui 

    -- no lugar do "req.body.customer", vamos passar o "data.id"